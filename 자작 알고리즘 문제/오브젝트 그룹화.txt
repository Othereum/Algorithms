오브젝트 그룹화

그래픽 프로그래밍을 할 때 신경써야 할 사항 중 하나가 상태 변경입니다. 쉐이더 프로그램을 변경하거나, 쉐이더에서 사용하는 변수(유니폼)의 값을 변경하거나, 텍스처를 변경하거나, 버텍스 배열을 변경하는 등, 그래픽카드에 접근하여 데이터를 전송해야 하는 모든 상태 변경 연산은 결코 빠른 연산이 아니기 때문에 주의해야 합니다.

화가가 그림을 그리는 것을 생각해봅시다. 붓과 물감을 사용하여 색을 칠할 때, 다른 색을 칠할 때마다 붓을 교체해야 합니다. 그러나 같은 색을 칠할 땐 같은 붓을 계속 쓰면 되므로 교체할 필요가 없습니다.

마찬가지로, 오브젝트를 렌더링할 때마다 각각 그 오브젝트에 해당하는 쉐이더/유니폼/텍스처/버텍스배열로 변경해줘야 합니다. 그러나 같은 것을 사용하는 오브젝트끼리 모아서 한번에 하면 상태를 변경할 필요가 없습니다. 그래서 최적화를 위해 오브젝트를 그룹화 하는것이 보통입니다.

상태 변경 비용은 쉐이더 -> 유니폼 -> 텍스처 -> 버텍스 배열 순으로 높습니다. 때문에 가장 먼저, 같은 쉐이더를 사용하는 오브젝트끼리 그룹화하고, 그 안에서도 마찬가지로 유니폼, 텍스처, 버텍스 순으로 그룹화를 하면 됩니다.

오브젝트를 표현한 구조체는 다음과 같습니다.

struct Shader;
struct Texture;
struct VertArr;

struct Material
{
    Shader* shader;
    Texture* texture;
    /* 유니폼 */
};

struct Drawable
{
    Material* material;
    VertArr* vert_arr;
};

Material은 쉐이더, 텍스처, 유니폼을 캡슐화한 객체입니다. 서로 다른 Material의 유니폼은 반드시 다릅니다(재설정 되어야 합니다). 그러나 shader와 texture는 같을 수 있습니다. 또한, 서로 다른 Drawable의 material과 vert_arr은 같을 수 있습니다. 다시 말해, 유니폼은 Material에 대해 고유하지만, 각 Material, Shader, Texture, VertArr은 공유될 수 있습니다.

렌더러에 오브젝트를 등록(배열에 삽입)할 때, 그룹화된 상태를 유지하며 삽입하려고 합니다. 두 오브젝트 a, b를 받아서 a가 b보다 앞쪽으로 정렬되어야 하는 경우 true를 반환하는 함수를 작성하세요.

bool compare(Drawable* a, Drawable* b);
